# Activity Timeline with Interactive Minimap

This repository contains my implementation of the take-home assignment for Upside, a Django + Next.js single-page application that features an interactive activity timeline table and a minimap line chart. The project was developed within a ~2-hour coding timebox, leveraging Cursor Agent (Web, not IDE) to accelerate development.

## Implementation Approach

I approached this project methodically to maximize efficiency within the 2-hour coding constraint:

1. **Initial Setup (Excluded from Timebox)**:
   - I began by thoroughly reviewing the repository structure, candidate instructions, and the provided skeleton code to understand the Django models (`Activity` with fields like `date`, `description`, `owner`, `channel`, `status`, `teams`) and Next.js frontend setup. This context-gathering phase was not counted toward the 2-hour coding time, as it involved no coding, only analysis.
   - I set up a Dockerized environment by creating the `Dockerfile`(s) and `docker-compose.yaml`, ensuring a reproducible setup for development and potential production deployment. This setup time was also excluded from the coding timebox, as it was preparatory infrastructure work.

2. **Development Process**:
   - **Backend (Django)**: I verified the SQLite configuration in `server/server/settings.py` and ensured migrations were applied automatically via `docker-compose.yaml` (`python manage.py migrate`). I implemented the `/api/activities/` endpoint using Django REST Framework, serializing `Activity` model data for the frontend. Sample data was seeded via a fixture (`initial_data.json`) to populate the database with activities for testing.
   - **Frontend (Next.js)**: I built the activity timeline table by designing a reusable Table component and the minimap line chart using `ChartJS`. The table displays columns for date, description, people (name with email tooltip), channel, status, and teams. The line chart shows daily counts of `direction: "IN"` activities, with click-to-navigate functionality to scroll the table to a selected date. Real-time sync updates the "active region" bars based on the table’s visible rows.
   - **AI Tool Usage**: I heavily leveraged Cursor Agent (web version) to generate boilerplate code for components, API calls, and styling. Each pull request (PR) was manually reviewed, with comments added for fixes or improvements. I broke features into small, focused PRs (e.g., table setup, chart rendering, API integration) to maintain clarity and track progress. Summaries were included in each PR to document changes.

3. **Challenges**:
   - I had to make a decision to the best of my knowledge of what I considered "coding" and "not coding" as part of the 2 hour coding scope. I didn't count the time I spent understanding the codebase, refreshing on some getting-started documentation for django and nextjs, and the docker environment setup.
   - I also didn't count the time between code generation because Cursor Agent would sometimes take, anywhere from 5-10 minutes depending on the request, and I had many issues with it that took ~9-10 hours debugging my issues with the Cursor Help Team.
   - I did count the time where I was reviewing the PRs generated by Cursor, making manual changes to the PRs, and debugging issues and cleaning up code. I made my decisions and I'm quite satisfied with how I timed myself and still try to keep relatively within the 2 hour coding scoping.
   - Cursor Agent’s web version introduced bugs and delays (e.g., 5-10 minute generation times, requiring ~6-7 hours of debugging with the Cursor support team via email). This debugging time was excluded from the 2-hour coding scope, as it was not active coding. Once resolved, Cursor significantly accelerated feature development.
   - A folder (/lib/) in the .gitignore prevented Cursor from pushing out features to that directory. This caused confusing and bugs with the Cursor Agent and myself resulting in spending about an hour to triage and resolve this issue. 

## TODOs and Improvements

With more time, I would prioritize the following enhancements:
- **Styling Polish**: Standardize spacing, gaps, font choices, and overall UI consistency using a CSS framework like Tailwind or custom styles. The current styling is functional but lacks the refined polish level that I hold myself to.
- **Non-functional features**: There's some buttons that just don't have any functionality at all that I would implement or remove if I had just a little bit more time.
- **First Touchpoint Markers**: Implement circular markers on the line chart for each person’s first activity. This was not completed due to the timebox but would enhance the minimap’s functionality.
- **Performance Optimization**: Optimize API queries (e.g., filter `direction: "IN"` server-side) and memoize React components to reduce re-renders during infinite scroll.
- **Error Handling**: Add more robust error states (e.g., empty data, network failures) with user-friendly messages via some kind of Toasting library in the UI.
- **Testing**: Add unit tests for critical components (e.g., table and chart) and API integration to ensure reliability.

## Architectural Decisions and Trade-offs

- **Timeboxing Scope**:
  - I excluded non-coding tasks (repo analysis, Docker setup, Cursor debugging) from the 2-hour limit, counting only active coding, PR reviews, and manual fixes. This allowed me to focus on delivering core functionality (infinite scroll table, line chart, click-to-navigate, active region sync) while staying close to the timebox.
  - The ~9-10 hours spent debugging Cursor Agent issues extended the calendar time but were not counted as coding, as they involved external support and waiting periods with the Cursor Help Team.
- **AI-Driven Development**:
  - Using Cursor Agent traded off my usual manual coding style for speed, enabling rapid feature implementation. While this reduced my "individual flair," the generated code adheres to Next.js and Django best practices, ensuring maintainability and alignment with official documentation.
  - Manual PR reviews ensured quality, catching AI-generated errors (e.g., incorrect imports) and allowing iterative improvements.
- **Small PRs**: Breaking changes into small PRs improved traceability and made debugging easier, though it required extra time for summaries and comments.
- **Pre-built Components**: I used libraries like `ChartJS` to meet the timebox, sacrificing custom-built solutions for faster delivery.
- **Docker Setup**: Investing in a robust Dockerized environment upfront simplified development and ensured consistency, though it took initial setup time (excluded from coding).

## Running the Project

1. **Prerequisites**:
   - Docker and Docker Compose installed.
   - Node.js and Python environments (if running locally).

2. **Setup**:
   ```bash
   docker-compose up --build --watch
   ```
   - Backend: Runs on `http://localhost:8000` (API at `/api/activities/`).
   - Frontend: Runs on `http://localhost:3000` (dashboard with table and chart).

3. **Database**:
   - SQLite (`db.sqlite3`) is used, persisted via a `sqlite_data` volume.
   - Migrations and sample data are applied automatically via `docker-compose.yaml`.

4. **Access**:
   - Dashboard: `http://localhost:3000`.
   - Admin (for data management): `http://localhost:8000/admin/` (create a superuser with `docker-compose exec web python manage.py createsuperuser`).

## Notes

- The implementation meets core requirements: infinite scroll table, line chart with activity counts, click-to-navigate, and active region sync.
- The UI is functional but would benefit from styling polish (TODO).
- I prioritized functionality over perfection, leveraging AI tools to deliver a working prototype within the timebox.
- Despite calendar time spanning two days due to Cursor debugging, actual coding time was kept near 2 hours by excluding setup and external delays.

Thank you for the opportunity! I enjoyed tackling this challenge and showcasing my ability to deliver a functional, interactive app under tight constraints.
